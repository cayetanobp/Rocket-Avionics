# Data Converter - CSV to Proteus Stimulus

## Propósito

Convierte los CSVs procesados de datos de vuelo en archivos de estímulo compatibles con Proteus VSM. Este es el puente entre los datos de vuelo reales (OpenRocket) y la simulación de hardware.

---

## Pipeline

```
processed/motor_H143_full.csv
         │
         ▼
┌─────────────────────┐
│  csv_to_stimulus.py  │
└─────────────────────┘
         │
         ├──→ mpu6050_i2c_registers.sdf    (registros I2C del MPU6050)
         ├──→ bmp280_i2c_registers.sdf     (registros I2C del BMP280)
         ├──→ gps_nmea_uart.txt            (stream NMEA para UART)
         └──→ ina219_i2c_registers.sdf     (registros I2C del INA219)
```

---

## Uso

```bash
# Instalar dependencias
pip install -r ../requirements.txt

# Convertir datos procesados a stimulus
python csv_to_stimulus.py --input ../../flight-data/processed/motor_H143_full.csv \
                          --output-dir ../../integration/full-system-simulation/stimulus/

# Generar solo un sensor específico
python csv_to_stimulus.py --input ../../flight-data/processed/motor_H143_full.csv \
                          --output-dir ./output/ \
                          --sensor imu
```

---

## Formato de Stimulus Proteus (.sdf)

Los archivos `.sdf` (Stimulus Data File) de Proteus definen valores que cambian en el tiempo:

```
; Proteus Stimulus File
; Generated by csv_to_stimulus.py
; Sensor: MPU6050 I2C Registers
;
; Time(s)    Register    Value
0.000        0x3B        0x00FF    ; ACCEL_XOUT_H/L = +1.00g
0.000        0x3D        0x0000    ; ACCEL_YOUT_H/L = 0.00g
0.000        0x3F        0x4000    ; ACCEL_ZOUT_H/L = +1.00g
0.010        0x3B        0x0105    ; ACCEL_XOUT_H/L = +1.02g
...
```

---

## Conversión por Sensor

### MPU6050 (IMU)

```python
def accel_g_to_raw(accel_g, full_scale=8):
    """Convierte aceleración en g a valor raw de 16 bits.
    
    MPU6050 con ±8g: sensibilidad = 4096 LSB/g
    """
    sensitivity = {2: 16384, 4: 8192, 8: 4096, 16: 2048}
    raw = int(accel_g * sensitivity[full_scale])
    return max(-32768, min(32767, raw))

def gyro_dps_to_raw(gyro_dps, full_scale=500):
    """Convierte velocidad angular en °/s a valor raw de 16 bits.
    
    MPU6050 con ±500°/s: sensibilidad = 65.5 LSB/(°/s)
    """
    sensitivity = {250: 131.0, 500: 65.5, 1000: 32.8, 2000: 16.4}
    raw = int(gyro_dps * sensitivity[full_scale])
    return max(-32768, min(32767, raw))
```

### BMP280 (Barómetro)

```python
def pressure_hpa_to_raw(pressure_hpa):
    """Convierte presión en hPa a valor raw de 20 bits del BMP280.
    
    BMP280: raw = pressure_Pa * 256 (con oversampling x16)
    Registros: 0xF7 (MSB), 0xF8 (LSB), 0xF9 (XLSB)
    """
    pressure_pa = pressure_hpa * 100.0
    raw = int(pressure_pa * 256)
    return raw & 0xFFFFF  # 20 bits

def temperature_c_to_raw(temperature_c):
    """Convierte temperatura en °C a valor raw de 20 bits del BMP280.
    
    BMP280: raw ≈ (temperature_c + 40) * 5120 (aproximación simplificada)
    Registros: 0xFA (MSB), 0xFB (LSB), 0xFC (XLSB)
    """
    raw = int((temperature_c + 40.0) * 5120)
    return raw & 0xFFFFF
```

### NEO-6M (GPS)

```python
def generate_nmea_gga(lat, lon, alt, time_s, fix_quality=1, num_sats=8):
    """Genera sentencia NMEA GGA.
    
    $GPGGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,,*hh
    """
    hours = int(time_s // 3600) % 24
    minutes = int((time_s % 3600) // 60)
    seconds = time_s % 60
    
    lat_deg = int(abs(lat))
    lat_min = (abs(lat) - lat_deg) * 60
    lat_dir = 'N' if lat >= 0 else 'S'
    
    lon_deg = int(abs(lon))
    lon_min = (abs(lon) - lon_deg) * 60
    lon_dir = 'E' if lon >= 0 else 'W'
    
    sentence = (f"$GPGGA,{hours:02d}{minutes:02d}{seconds:05.2f},"
                f"{lat_deg:02d}{lat_min:07.4f},{lat_dir},"
                f"{lon_deg:03d}{lon_min:07.4f},{lon_dir},"
                f"{fix_quality},{num_sats:02d},1.0,"
                f"{alt:.1f},M,0.0,M,,")
    
    # Checksum
    checksum = 0
    for c in sentence[1:]:  # Skip $
        checksum ^= ord(c)
    
    return f"{sentence}*{checksum:02X}"
```

---

## Archivo Principal

```python
#!/usr/bin/env python3
"""
csv_to_stimulus.py
Convierte CSV procesado de vuelo a archivos de estímulo para Proteus.

Genera:
  - mpu6050_i2c_registers.sdf  (accel + gyro raw values)
  - bmp280_i2c_registers.sdf   (pressure + temp raw values)
  - gps_nmea_uart.txt           (sentencias NMEA con timing)
  - ina219_i2c_registers.sdf   (voltage + current raw values)
"""

import argparse
import os
import numpy as np
import pandas as pd

# [Funciones de conversión aquí - ver secciones anteriores]

def generate_mpu6050_stimulus(df, output_path):
    """Genera stimulus para MPU6050."""
    with open(output_path, 'w') as f:
        f.write("; MPU6050 I2C Register Stimulus\n")
        f.write("; Generated from flight profile\n")
        f.write("; Format: time_s, register_addr, value_16bit\n\n")
        
        for _, row in df.iterrows():
            t = row['time_s']
            ax = accel_g_to_raw(row['accel_x_g'])
            ay = accel_g_to_raw(row['accel_y_g'])
            az = accel_g_to_raw(row['accel_z_g'])
            gx = gyro_dps_to_raw(row['gyro_x_dps'])
            gy = gyro_dps_to_raw(row['gyro_y_dps'])
            gz = gyro_dps_to_raw(row['gyro_z_dps'])
            
            f.write(f"{t:.3f}  0x3B  0x{ax & 0xFFFF:04X}  ; ACCEL_X = {row['accel_x_g']:.3f}g\n")
            f.write(f"{t:.3f}  0x3D  0x{ay & 0xFFFF:04X}  ; ACCEL_Y = {row['accel_y_g']:.3f}g\n")
            f.write(f"{t:.3f}  0x3F  0x{az & 0xFFFF:04X}  ; ACCEL_Z = {row['accel_z_g']:.3f}g\n")
            f.write(f"{t:.3f}  0x43  0x{gx & 0xFFFF:04X}  ; GYRO_X = {row['gyro_x_dps']:.1f}°/s\n")
            f.write(f"{t:.3f}  0x45  0x{gy & 0xFFFF:04X}  ; GYRO_Y = {row['gyro_y_dps']:.1f}°/s\n")
            f.write(f"{t:.3f}  0x47  0x{gz & 0xFFFF:04X}  ; GYRO_Z = {row['gyro_z_dps']:.1f}°/s\n")
    
    print(f"  MPU6050 stimulus: {output_path}")

def generate_bmp280_stimulus(df, output_path):
    """Genera stimulus para BMP280."""
    with open(output_path, 'w') as f:
        f.write("; BMP280 I2C Register Stimulus\n")
        f.write("; Generated from flight profile\n\n")
        
        for _, row in df.iterrows():
            t = row['time_s']
            p_raw = pressure_hpa_to_raw(row['pressure_hpa'])
            temp_k = row.get('temperature_k', 288.15)
            t_raw = temperature_c_to_raw(temp_k - 273.15)
            
            f.write(f"{t:.3f}  0xF7  0x{(p_raw >> 12) & 0xFF:02X}  ; PRESS_MSB\n")
            f.write(f"{t:.3f}  0xF8  0x{(p_raw >> 4) & 0xFF:02X}  ; PRESS_LSB\n")
            f.write(f"{t:.3f}  0xF9  0x{(p_raw << 4) & 0xFF:02X}  ; PRESS_XLSB\n")
            f.write(f"{t:.3f}  0xFA  0x{(t_raw >> 12) & 0xFF:02X}  ; TEMP_MSB\n")
            f.write(f"{t:.3f}  0xFB  0x{(t_raw >> 4) & 0xFF:02X}  ; TEMP_LSB\n")
            f.write(f"{t:.3f}  0xFC  0x{(t_raw << 4) & 0xFF:02X}  ; TEMP_XLSB\n")
    
    print(f"  BMP280 stimulus: {output_path}")

def generate_gps_stimulus(df, output_path):
    """Genera stream NMEA para GPS."""
    with open(output_path, 'w') as f:
        f.write("; GPS NMEA Stream\n")
        f.write("; 1Hz update rate (typical NEO-6M)\n\n")
        
        # GPS a 1Hz, interpolar si datos son más densos
        gps_times = np.arange(0, df['time_s'].max(), 1.0)
        
        for t in gps_times:
            idx = (df['time_s'] - t).abs().idxmin()
            row = df.loc[idx]
            
            gga = generate_nmea_gga(
                row['latitude'], row['longitude'],
                row.get('gps_altitude_m', row['altitude_m']),
                t
            )
            f.write(f"; t={t:.1f}s\n")
            f.write(f"{gga}\n")
    
    print(f"  GPS NMEA stimulus: {output_path}")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--input', required=True, help='Processed CSV path')
    parser.add_argument('--output-dir', required=True, help='Output directory')
    parser.add_argument('--sensor', default='all',
                        choices=['all', 'imu', 'baro', 'gps'],
                        help='Which sensor stimulus to generate')
    args = parser.parse_args()
    
    os.makedirs(args.output_dir, exist_ok=True)
    df = pd.read_csv(args.input)
    print(f"Loaded {len(df)} data points from {args.input}")
    
    if args.sensor in ('all', 'imu'):
        generate_mpu6050_stimulus(df, os.path.join(args.output_dir, 'mpu6050_i2c_registers.sdf'))
    if args.sensor in ('all', 'baro'):
        generate_bmp280_stimulus(df, os.path.join(args.output_dir, 'bmp280_i2c_registers.sdf'))
    if args.sensor in ('all', 'gps'):
        generate_gps_stimulus(df, os.path.join(args.output_dir, 'gps_nmea_uart.txt'))
    
    print("\nDone! Load stimulus files in Proteus simulation.")

if __name__ == '__main__':
    main()
```

---

## Siguiente Paso

> Implementar `csv_to_stimulus.py` como archivo ejecutable y probarlo con un perfil de vuelo sintético generado por `generate_synthetic_flight.py`.
